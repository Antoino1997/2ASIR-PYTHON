# AUTOMATE THE BORING STUFF WITH PYTHON

## CHAPTER 1 - PYTHON BASICS
Ejercicio | Descripción
----------|------------
[Ejercicio1](rectPrint.py) | Write a program that prints a rectangle of capital O characters. The program should always print a rectangle of O characters that has a height of five (that is, five rows), but the width should be based on an integer the user enters.
[Ejercicio2](perimeterAreaCalculator.py) | Write a program that accepts the width and length of a rectangular space from the user and then calculates both the perimeter and area of this space.

## CHAPTER 2 - IF-ELSE AND FLOW CONTROL
Ejercicio | Descripción
----------|------------
[Ejercicio1](safeTemp.py) | The following program reports whether a given temperature is safe. It asks the user to enter a temperature in two parts. First, they should enter C or F to indicate the Celsius or Fahrenheit scale; second, they should enter the number of degrees. If the temperature is between 16 and 38 degrees Celsius (inclusive of 16 and 38) or between 60.8 and 100.4 degrees Fahrenheit (inclusive of 60.8 and 100.4), the program prints Safe. Outside of these temperature ranges, the program prints Dangerous. This program has bugs, however. Rewrite the code to fix the errors. You may assume the user always enters valid inputs and not, say, X for the scale or hello for the number of degrees.
[Ejercicio2](safeTempExpr.py) | It’s possible to write the safe temperature logic of the previous program in a single condition. Fill in the blank in the following program with this condition to make it work in the same way as the previous program.
[Ejercicio3](fizzBuzzNumber.py) | Fizz Buzz is a common programming challenge that goes like this. Write a program that accepts an integer from the user. If the integer is divisible by 3, the program should print Fizz. If the integer is divisible by 5, the program should print Buzz. If the integer is divisible by 3 and 5, the program should print Fizz Buzz. Otherwise, the program should print the number the user entered.

## CHAPTER 3 - LOOPS
Ejercicio | Descripción
----------|------------
[Ejercicio1](treePrint.py) | Use a for loop to print a triangular pine tree of a size the user asks for. The tree branches should be printed as a number of rows of ^ characters, while the trunk should always be two # characters. As a second exercise, write this same program using while loops instead of for loops.
[Ejercicio2](xmasTreePrint.py) | Instead of creating a plain tree like the one in the previous project, write a program that prints a Christmas tree with o ball ornaments randomly replacing ^ branch characters. As a second exercise, write this same program using while loops instead of for loops.

## CHAPTER 4 - FUNCTIONS
Ejercicio | Descripción
----------|------------
[Ejercicio1](transactionTracker.py) | Write a function named after_transaction() that returns the amount of money in an account after a transaction. The two parameters for this function are balance and transaction. They will both have integer arguments. The balance is how much money is currently in the account, and the transaction is how much to add or remove from the account (based on whether transaction is a positive or negative integer). This operation is more complicated than just return balance + transaction. If the transaction is negative and would overdraw the account (that is, if balance + transaction is less than zero), then the transaction should be ignored and the original balance returned. 
[Ejercicio2](arithmeticFunctions.py) | Let’s create add(number1, number2) and multiply(number1, number2) functions that add and multiply their arguments without using the + or * operators. These functions will be quite inefficient, but don’t worry; the computer doesn’t mind. Your add() function should not use the + operator; rather, it should have loops that repeatedly call the plus_one() function to perform the addition operation on the operands passed as parameters. After all, the operation 4 + 3 is the same as 4 + 1 + 1 + 1. Your add() function is expected to handle positive integers only. Your multiply() function should work in the same way: Avoid using the * operator, and instead use a loop to repeatedly call your add() function. After all, the operation 3 * 5 is the same as 3 + 3 + 3 + 3 + 3 or 5 + 5 + 5. It’s a good idea to make sure your add() function works before beginning on multiply(). Also note that 2 + 8 is the same as 8 + 2 and 2 * 8 is the same as 8 * 2.
[Ejercicio3](tickTockPrint.py) | The time.sleep() function, which pauses program execution for a specified amount of time, is useful, but rather plain. Let’s write our own tick_tock(seconds) function that also pauses for seconds amount of time but prints Tick... and Tock... each second while waiting. You may assume that the seconds parameter always has a positive integer argument. Keep in mind that if the argument for seconds is odd, the last thing the function should print is Tick...

## CHAPTER 5 - DEBUGGING
Ejercicio | Descripción
----------|------------
[Ejercicio1](buggygradeaverage.py) | Copy the following program into your editor or download it from https://autbor.com/buggygradeaverage.py. This program lets the user enter any number of grades until the user enters done. It then displays the average of the entered grades. When you run the program and enter 100 and 50, however, it reports the average as 0 instead of 75. Run this program under a debugger to find out why it doesn’t work, then fix the bug. (Note that if the user enters a response other than done or a number, the program crashes; ignore this bug for now.)
[Ejercicio2](zeroDivisionError.py) | Take a look at your corrected version of the previous grade-average program. If you run this program and immediately enter done without entering any grades, the program crashes with a ZeroDivisionError: division by zero error. Use the debugger to find out why this happens. Add code to the calculate_grade_average() function so that it returns the integer 0 when the user hasn’t entered any grades, instead of crashing.
[Ejercicio3](leapYearCalculator.py) | Copy the following program into your editor or download it from https://autbor.com/buggyLeapYear.py. This program has an is_leap_year() function that takes an integer year, then returns True if it’s a leap year and False if it isn’t. A year is a leap year if it is evenly divisible by 4. An exception to this rule occurs if the year is also evenly divisible by 100, in which case it is not a leap year. There is an exception to that exception too: If the year is also evenly divisible by 400, it is a leap year. The year 2100 should not be a leap year, but the function call is_leap_year(2100) incorrectly returns True. Run this code under a debugger so that you can see where exactly the bug is, and then write the corrected is_leap_year() function.
[Ejercicio4](writingBuggyCodeonPurpose.py) | Write several short programs that produce the given error message in the following list. If you’re unfamiliar with the error message, search for it on the internet to find bug reports from others who have encountered it. The filename is a hint for writing the program. <br/>- A program named nameError.py that produces the error message NameError: name 'spam' is not defined<br/>- A program named badInt.py that produces the error message ValueError: invalid literal for int() with base 10: 'five'<br/>- A program named badEquals.py that produces the error message SyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?<br/>- A program named badString.py that produces the error message SyntaxError: unterminated string literal (detected at line x) (where x can be any number)<br/>- A program named badBool.py that produces the error message NameError: name 'true' is not defined. Did you mean: 'True'?<br/>- A program named missingIfBlock.py that produces the error message IndentationError: expected an indented block after 'if' statement on line x (where x can be any number)<br/>- A program named stringPlusInt.py that produces the error message TypeError: can only concatenate str (not "int") to str<br/>- A program named intPlusString.py that produces the error message TypeError: unsupported operand type(s) for +: 'int' and 'str'

## CHAPTER 6 - LISTS
Ejercicio | Descripción
----------|------------
[Ejercicio1](pangramDetector.py) | Write a function named is_pangram(sentence) that accepts a string argument, then returns True if it’s a pangram and False if not. A pangram is a sentence that uses all 26 letters of the alphabet at least once. For example, “The quick brown fox jumps over the yellow lazy dog” is a pangram. There are several ways to accomplish this task. One way is to have a variable named EACH_LETTER that starts as an empty list. Then, you can loop over the characters in the string argument, convert each to uppercase with the upper() method, and append it to the EACH_LETTER list if it is a letter and doesn’t already exist there. You can tell that a letter in char isn’t already in the EACH_LETTER list because the expression char not in EACH_LETTER will evaluate to True. After looping over each character in the user’s string, you’ll know that the string is a pangram if len(EACH_LETTER) evaluates to 26.
[Ejercicio2](coordinateDirections.py) | Write a function named get_end_coordinates(directions) that accepts a list of north, south, east, and west directions and returns a numeric pair of Cartesian coordinates. The first part of the program should repeatedly ask the user to enter N, S, E, or W (but should accept the lowercase n, s, e, and w as well) and should collect these inputs in a list. The loop should exit when the user enters a blank string. Next, the program should pass the list to the get_end_coordinates() function. Going north should increase the y-coordinate by one, while going south should decrease it by one. Likewise, going east should increase the x-coordinate by one, while going west should decrease it by one. You can represent the coordinates in another list. For example, the function call get_end_coordinates(['N', 'N', 'W']) should return the list [-1, 2], and the function call get_end_coordinates(['E', 'W', 'E', 'E']) should return the coordinates [2, 0]. Your program should print the list returned by get_end_coordinates().
